{"version":3,"file":"csr.mjs","sources":["../../../src/client/ctx.tsx","../../../src/client/entries/ClientAppWrapper.tsx","../../../../../node_modules/.pnpm/jotai@2.6.2_@types+react@18.2.48_react@18.2.0/node_modules/jotai/esm/vanilla.mjs","../../../../../node_modules/.pnpm/jotai@2.6.2_@types+react@18.2.48_react@18.2.0/node_modules/jotai/esm/react.mjs","../../../../../node_modules/.pnpm/jotai@2.6.2_@types+react@18.2.48_react@18.2.0/node_modules/jotai/esm/vanilla/utils.mjs","../../../src/client/state.ts","../../../src/client/utils.ts","../../../src/client/useAppState.tsx","../../../src/client/PageLoader.tsx","../../../src/client/App.tsx","../../../src/client/entries/csr.tsx"],"sourcesContent":["import { createContext } from 'react'\nimport type { PagesLoaded } from '../../clientTypes'\n\n/**\n * During ssr hydration, we pass all the data needed by App\n * with this ctx\n * so the App can render the page data directly\n * instead of render the loading state\n */\nexport const dataCacheCtx = createContext<PagesLoaded>({})\nexport const setDataCacheCtx = createContext<\n  React.Dispatch<React.SetStateAction<PagesLoaded>>\n>(() => {\n  throw new Error(`setDataCacheCtx not found`)\n})\n","/// <reference types=\"vite/client\" />\n\n/**\n * This is a common wrapper component for csr.tsx and ssg-client.tsx\n */\n\nimport React, { useState } from 'react'\nimport { HashRouter, BrowserRouter } from 'react-router-dom'\nimport { dataCacheCtx, setDataCacheCtx } from '../ctx'\nimport type { PageLoaded } from '../../../clientTypes'\n\n// @ts-expect-error\nconst Router = __HASH_ROUTER__ ? HashRouter : BrowserRouter\n// @ts-expect-error\nconst basename = __HASH_ROUTER__\n  ? undefined\n  : import.meta.env.BASE_URL?.replace(/\\/$/, '')\n\ninterface Props {\n  readonly initCache?: PageLoaded\n  readonly children: React.ReactNode\n}\n\nconst ClientAppWrapper: React.FC<React.PropsWithChildren<Props>> = ({\n  initCache,\n  children,\n}) => {\n  const [dataCache, setDataCache] = useState<PageLoaded>(initCache ?? {})\n  return (\n    <Router basename={basename}>\n      <dataCacheCtx.Provider value={dataCache}>\n        <setDataCacheCtx.Provider value={setDataCache}>\n          {children}\n        </setDataCacheCtx.Provider>\n      </dataCacheCtx.Provider>\n    </Router>\n  )\n}\n\nexport default ClientAppWrapper\n","let keyCount = 0;\nfunction atom(read, write) {\n  const key = `atom${++keyCount}`;\n  const config = {\n    toString: () => key\n  };\n  if (typeof read === \"function\") {\n    config.read = read;\n  } else {\n    config.init = read;\n    config.read = function(get) {\n      return get(this);\n    };\n    config.write = function(get, set, arg) {\n      return set(\n        this,\n        typeof arg === \"function\" ? arg(get(this)) : arg\n      );\n    };\n  }\n  if (write) {\n    config.write = write;\n  }\n  return config;\n}\n\nconst hasInitialValue = (atom) => \"init\" in atom;\nconst isActuallyWritableAtom = (atom) => !!atom.write;\nconst cancelPromiseMap = /* @__PURE__ */ new WeakMap();\nconst registerCancelPromise = (promise, cancel) => {\n  cancelPromiseMap.set(promise, cancel);\n  promise.catch(() => {\n  }).finally(() => cancelPromiseMap.delete(promise));\n};\nconst cancelPromise = (promise, next) => {\n  const cancel = cancelPromiseMap.get(promise);\n  if (cancel) {\n    cancelPromiseMap.delete(promise);\n    cancel(next);\n  }\n};\nconst resolvePromise = (promise, value) => {\n  promise.status = \"fulfilled\";\n  promise.value = value;\n};\nconst rejectPromise = (promise, e) => {\n  promise.status = \"rejected\";\n  promise.reason = e;\n};\nconst isPromiseLike = (x) => typeof (x == null ? void 0 : x.then) === \"function\";\nconst isEqualAtomValue = (a, b) => !!a && \"v\" in a && \"v\" in b && Object.is(a.v, b.v);\nconst isEqualAtomError = (a, b) => !!a && \"e\" in a && \"e\" in b && Object.is(a.e, b.e);\nconst hasPromiseAtomValue = (a) => !!a && \"v\" in a && a.v instanceof Promise;\nconst isEqualPromiseAtomValue = (a, b) => \"v\" in a && \"v\" in b && a.v.orig && a.v.orig === b.v.orig;\nconst returnAtomValue = (atomState) => {\n  if (\"e\" in atomState) {\n    throw atomState.e;\n  }\n  return atomState.v;\n};\nconst createStore = () => {\n  const atomStateMap = /* @__PURE__ */ new WeakMap();\n  const mountedMap = /* @__PURE__ */ new WeakMap();\n  const pendingMap = /* @__PURE__ */ new Map();\n  let storeListenersRev2;\n  let mountedAtoms;\n  if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n    storeListenersRev2 = /* @__PURE__ */ new Set();\n    mountedAtoms = /* @__PURE__ */ new Set();\n  }\n  const getAtomState = (atom) => atomStateMap.get(atom);\n  const setAtomState = (atom, atomState) => {\n    if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n      Object.freeze(atomState);\n    }\n    const prevAtomState = atomStateMap.get(atom);\n    atomStateMap.set(atom, atomState);\n    if (!pendingMap.has(atom)) {\n      pendingMap.set(atom, prevAtomState);\n    }\n    if (hasPromiseAtomValue(prevAtomState)) {\n      const next = \"v\" in atomState ? atomState.v instanceof Promise ? atomState.v : Promise.resolve(atomState.v) : Promise.reject(atomState.e);\n      if (prevAtomState.v !== next) {\n        cancelPromise(prevAtomState.v, next);\n      }\n    }\n  };\n  const updateDependencies = (atom, nextAtomState, nextDependencies) => {\n    const dependencies = /* @__PURE__ */ new Map();\n    let changed = false;\n    nextDependencies.forEach((aState, a) => {\n      if (!aState && a === atom) {\n        aState = nextAtomState;\n      }\n      if (aState) {\n        dependencies.set(a, aState);\n        if (nextAtomState.d.get(a) !== aState) {\n          changed = true;\n        }\n      } else if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n        console.warn(\"[Bug] atom state not found\");\n      }\n    });\n    if (changed || nextAtomState.d.size !== dependencies.size) {\n      nextAtomState.d = dependencies;\n    }\n  };\n  const setAtomValue = (atom, value, nextDependencies) => {\n    const prevAtomState = getAtomState(atom);\n    const nextAtomState = {\n      d: (prevAtomState == null ? void 0 : prevAtomState.d) || /* @__PURE__ */ new Map(),\n      v: value\n    };\n    if (nextDependencies) {\n      updateDependencies(atom, nextAtomState, nextDependencies);\n    }\n    if (isEqualAtomValue(prevAtomState, nextAtomState) && prevAtomState.d === nextAtomState.d) {\n      return prevAtomState;\n    }\n    if (hasPromiseAtomValue(prevAtomState) && hasPromiseAtomValue(nextAtomState) && isEqualPromiseAtomValue(prevAtomState, nextAtomState)) {\n      if (prevAtomState.d === nextAtomState.d) {\n        return prevAtomState;\n      } else {\n        nextAtomState.v = prevAtomState.v;\n      }\n    }\n    setAtomState(atom, nextAtomState);\n    return nextAtomState;\n  };\n  const setAtomValueOrPromise = (atom, valueOrPromise, nextDependencies, abortPromise) => {\n    if (isPromiseLike(valueOrPromise)) {\n      let continuePromise;\n      const updatePromiseDependencies = () => {\n        const prevAtomState = getAtomState(atom);\n        if (!hasPromiseAtomValue(prevAtomState) || prevAtomState.v !== promise) {\n          return;\n        }\n        const nextAtomState = setAtomValue(\n          atom,\n          promise,\n          nextDependencies\n        );\n        if (mountedMap.has(atom) && prevAtomState.d !== nextAtomState.d) {\n          mountDependencies(atom, nextAtomState, prevAtomState.d);\n        }\n      };\n      const promise = new Promise((resolve, reject) => {\n        let settled = false;\n        valueOrPromise.then(\n          (v) => {\n            if (!settled) {\n              settled = true;\n              resolvePromise(promise, v);\n              resolve(v);\n              updatePromiseDependencies();\n            }\n          },\n          (e) => {\n            if (!settled) {\n              settled = true;\n              rejectPromise(promise, e);\n              reject(e);\n              updatePromiseDependencies();\n            }\n          }\n        );\n        continuePromise = (next) => {\n          if (!settled) {\n            settled = true;\n            next.then(\n              (v) => resolvePromise(promise, v),\n              (e) => rejectPromise(promise, e)\n            );\n            resolve(next);\n          }\n        };\n      });\n      promise.orig = valueOrPromise;\n      promise.status = \"pending\";\n      registerCancelPromise(promise, (next) => {\n        if (next) {\n          continuePromise(next);\n        }\n        abortPromise == null ? void 0 : abortPromise();\n      });\n      return setAtomValue(atom, promise, nextDependencies);\n    }\n    return setAtomValue(atom, valueOrPromise, nextDependencies);\n  };\n  const setAtomError = (atom, error, nextDependencies) => {\n    const prevAtomState = getAtomState(atom);\n    const nextAtomState = {\n      d: (prevAtomState == null ? void 0 : prevAtomState.d) || /* @__PURE__ */ new Map(),\n      e: error\n    };\n    if (nextDependencies) {\n      updateDependencies(atom, nextAtomState, nextDependencies);\n    }\n    if (isEqualAtomError(prevAtomState, nextAtomState) && prevAtomState.d === nextAtomState.d) {\n      return prevAtomState;\n    }\n    setAtomState(atom, nextAtomState);\n    return nextAtomState;\n  };\n  const readAtomState = (atom, force) => {\n    const atomState = getAtomState(atom);\n    if (!force && atomState) {\n      if (mountedMap.has(atom)) {\n        return atomState;\n      }\n      if (Array.from(atomState.d).every(([a, s]) => {\n        if (a === atom) {\n          return true;\n        }\n        const aState = readAtomState(a);\n        return aState === s || isEqualAtomValue(aState, s);\n      })) {\n        return atomState;\n      }\n    }\n    const nextDependencies = /* @__PURE__ */ new Map();\n    let isSync = true;\n    const getter = (a) => {\n      if (a === atom) {\n        const aState2 = getAtomState(a);\n        if (aState2) {\n          nextDependencies.set(a, aState2);\n          return returnAtomValue(aState2);\n        }\n        if (hasInitialValue(a)) {\n          nextDependencies.set(a, void 0);\n          return a.init;\n        }\n        throw new Error(\"no atom init\");\n      }\n      const aState = readAtomState(a);\n      nextDependencies.set(a, aState);\n      return returnAtomValue(aState);\n    };\n    let controller;\n    let setSelf;\n    const options = {\n      get signal() {\n        if (!controller) {\n          controller = new AbortController();\n        }\n        return controller.signal;\n      },\n      get setSelf() {\n        if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\" && !isActuallyWritableAtom(atom)) {\n          console.warn(\"setSelf function cannot be used with read-only atom\");\n        }\n        if (!setSelf && isActuallyWritableAtom(atom)) {\n          setSelf = (...args) => {\n            if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\" && isSync) {\n              console.warn(\"setSelf function cannot be called in sync\");\n            }\n            if (!isSync) {\n              return writeAtom(atom, ...args);\n            }\n          };\n        }\n        return setSelf;\n      }\n    };\n    try {\n      const valueOrPromise = atom.read(getter, options);\n      return setAtomValueOrPromise(\n        atom,\n        valueOrPromise,\n        nextDependencies,\n        () => controller == null ? void 0 : controller.abort()\n      );\n    } catch (error) {\n      return setAtomError(atom, error, nextDependencies);\n    } finally {\n      isSync = false;\n    }\n  };\n  const readAtom = (atom) => returnAtomValue(readAtomState(atom));\n  const addAtom = (atom) => {\n    let mounted = mountedMap.get(atom);\n    if (!mounted) {\n      mounted = mountAtom(atom);\n    }\n    return mounted;\n  };\n  const canUnmountAtom = (atom, mounted) => !mounted.l.size && (!mounted.t.size || mounted.t.size === 1 && mounted.t.has(atom));\n  const delAtom = (atom) => {\n    const mounted = mountedMap.get(atom);\n    if (mounted && canUnmountAtom(atom, mounted)) {\n      unmountAtom(atom);\n    }\n  };\n  const recomputeDependents = (atom) => {\n    const dependencyMap = /* @__PURE__ */ new Map();\n    const dirtyMap = /* @__PURE__ */ new WeakMap();\n    const getDependents = (a) => {\n      var _a;\n      const dependents = new Set((_a = mountedMap.get(a)) == null ? void 0 : _a.t);\n      pendingMap.forEach((_, pendingAtom) => {\n        var _a2;\n        if ((_a2 = getAtomState(pendingAtom)) == null ? void 0 : _a2.d.has(a)) {\n          dependents.add(pendingAtom);\n        }\n      });\n      return dependents;\n    };\n    const loop1 = (a) => {\n      getDependents(a).forEach((dependent) => {\n        if (dependent !== a) {\n          dependencyMap.set(\n            dependent,\n            (dependencyMap.get(dependent) || /* @__PURE__ */ new Set()).add(a)\n          );\n          dirtyMap.set(dependent, (dirtyMap.get(dependent) || 0) + 1);\n          loop1(dependent);\n        }\n      });\n    };\n    loop1(atom);\n    const loop2 = (a) => {\n      getDependents(a).forEach((dependent) => {\n        var _a;\n        if (dependent !== a) {\n          let dirtyCount = dirtyMap.get(dependent);\n          if (dirtyCount) {\n            dirtyMap.set(dependent, --dirtyCount);\n          }\n          if (!dirtyCount) {\n            let isChanged = !!((_a = dependencyMap.get(dependent)) == null ? void 0 : _a.size);\n            if (isChanged) {\n              const prevAtomState = getAtomState(dependent);\n              const nextAtomState = readAtomState(dependent, true);\n              isChanged = !isEqualAtomValue(prevAtomState, nextAtomState);\n            }\n            if (!isChanged) {\n              dependencyMap.forEach((s) => s.delete(dependent));\n            }\n          }\n          loop2(dependent);\n        }\n      });\n    };\n    loop2(atom);\n  };\n  const writeAtomState = (atom, ...args) => {\n    let isSync = true;\n    const getter = (a) => returnAtomValue(readAtomState(a));\n    const setter = (a, ...args2) => {\n      let r;\n      if (a === atom) {\n        if (!hasInitialValue(a)) {\n          throw new Error(\"atom not writable\");\n        }\n        const prevAtomState = getAtomState(a);\n        const nextAtomState = setAtomValueOrPromise(a, args2[0]);\n        if (!isEqualAtomValue(prevAtomState, nextAtomState)) {\n          recomputeDependents(a);\n        }\n      } else {\n        r = writeAtomState(a, ...args2);\n      }\n      if (!isSync) {\n        const flushed = flushPending();\n        if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n          storeListenersRev2.forEach(\n            (l) => l({ type: \"async-write\", flushed })\n          );\n        }\n      }\n      return r;\n    };\n    const result = atom.write(getter, setter, ...args);\n    isSync = false;\n    return result;\n  };\n  const writeAtom = (atom, ...args) => {\n    const result = writeAtomState(atom, ...args);\n    const flushed = flushPending();\n    if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n      storeListenersRev2.forEach(\n        (l) => l({ type: \"write\", flushed })\n      );\n    }\n    return result;\n  };\n  const mountAtom = (atom, initialDependent, onMountQueue) => {\n    var _a;\n    const queue = onMountQueue || [];\n    (_a = getAtomState(atom)) == null ? void 0 : _a.d.forEach((_, a) => {\n      const aMounted = mountedMap.get(a);\n      if (aMounted) {\n        aMounted.t.add(atom);\n      } else {\n        if (a !== atom) {\n          mountAtom(a, atom, queue);\n        }\n      }\n    });\n    readAtomState(atom);\n    const mounted = {\n      t: new Set(initialDependent && [initialDependent]),\n      l: /* @__PURE__ */ new Set()\n    };\n    mountedMap.set(atom, mounted);\n    if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n      mountedAtoms.add(atom);\n    }\n    if (isActuallyWritableAtom(atom) && atom.onMount) {\n      const { onMount } = atom;\n      queue.push(() => {\n        const onUnmount = onMount((...args) => writeAtom(atom, ...args));\n        if (onUnmount) {\n          mounted.u = onUnmount;\n        }\n      });\n    }\n    if (!onMountQueue) {\n      queue.forEach((f) => f());\n    }\n    return mounted;\n  };\n  const unmountAtom = (atom) => {\n    var _a;\n    const onUnmount = (_a = mountedMap.get(atom)) == null ? void 0 : _a.u;\n    if (onUnmount) {\n      onUnmount();\n    }\n    mountedMap.delete(atom);\n    if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n      mountedAtoms.delete(atom);\n    }\n    const atomState = getAtomState(atom);\n    if (atomState) {\n      if (hasPromiseAtomValue(atomState)) {\n        cancelPromise(atomState.v);\n      }\n      atomState.d.forEach((_, a) => {\n        if (a !== atom) {\n          const mounted = mountedMap.get(a);\n          if (mounted) {\n            mounted.t.delete(atom);\n            if (canUnmountAtom(a, mounted)) {\n              unmountAtom(a);\n            }\n          }\n        }\n      });\n    } else if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n      console.warn(\"[Bug] could not find atom state to unmount\", atom);\n    }\n  };\n  const mountDependencies = (atom, atomState, prevDependencies) => {\n    const depSet = new Set(atomState.d.keys());\n    const maybeUnmountAtomSet = /* @__PURE__ */ new Set();\n    prevDependencies == null ? void 0 : prevDependencies.forEach((_, a) => {\n      if (depSet.has(a)) {\n        depSet.delete(a);\n        return;\n      }\n      maybeUnmountAtomSet.add(a);\n      const mounted = mountedMap.get(a);\n      if (mounted) {\n        mounted.t.delete(atom);\n      }\n    });\n    depSet.forEach((a) => {\n      const mounted = mountedMap.get(a);\n      if (mounted) {\n        mounted.t.add(atom);\n      } else if (mountedMap.has(atom)) {\n        mountAtom(a, atom);\n      }\n    });\n    maybeUnmountAtomSet.forEach((a) => {\n      const mounted = mountedMap.get(a);\n      if (mounted && canUnmountAtom(a, mounted)) {\n        unmountAtom(a);\n      }\n    });\n  };\n  const flushPending = () => {\n    let flushed;\n    if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n      flushed = /* @__PURE__ */ new Set();\n    }\n    while (pendingMap.size) {\n      const pending = Array.from(pendingMap);\n      pendingMap.clear();\n      pending.forEach(([atom, prevAtomState]) => {\n        const atomState = getAtomState(atom);\n        if (atomState) {\n          const mounted = mountedMap.get(atom);\n          if (mounted && atomState.d !== (prevAtomState == null ? void 0 : prevAtomState.d)) {\n            mountDependencies(atom, atomState, prevAtomState == null ? void 0 : prevAtomState.d);\n          }\n          if (mounted && !// TODO This seems pretty hacky. Hope to fix it.\n          // Maybe we could `mountDependencies` in `setAtomState`?\n          (!hasPromiseAtomValue(prevAtomState) && (isEqualAtomValue(prevAtomState, atomState) || isEqualAtomError(prevAtomState, atomState)))) {\n            mounted.l.forEach((listener) => listener());\n            if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n              flushed.add(atom);\n            }\n          }\n        } else if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n          console.warn(\"[Bug] no atom state to flush\");\n        }\n      });\n    }\n    if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n      return flushed;\n    }\n  };\n  const subscribeAtom = (atom, listener) => {\n    const mounted = addAtom(atom);\n    const flushed = flushPending();\n    const listeners = mounted.l;\n    listeners.add(listener);\n    if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n      storeListenersRev2.forEach(\n        (l) => l({ type: \"sub\", flushed })\n      );\n    }\n    return () => {\n      listeners.delete(listener);\n      delAtom(atom);\n      if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n        storeListenersRev2.forEach((l) => l({ type: \"unsub\" }));\n      }\n    };\n  };\n  if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n    return {\n      get: readAtom,\n      set: writeAtom,\n      sub: subscribeAtom,\n      // store dev methods (these are tentative and subject to change without notice)\n      dev_subscribe_store: (l, rev) => {\n        if (rev !== 2) {\n          throw new Error(\"The current StoreListener revision is 2.\");\n        }\n        storeListenersRev2.add(l);\n        return () => {\n          storeListenersRev2.delete(l);\n        };\n      },\n      dev_get_mounted_atoms: () => mountedAtoms.values(),\n      dev_get_atom_state: (a) => atomStateMap.get(a),\n      dev_get_mounted: (a) => mountedMap.get(a),\n      dev_restore_atoms: (values) => {\n        for (const [atom, valueOrPromise] of values) {\n          if (hasInitialValue(atom)) {\n            setAtomValueOrPromise(atom, valueOrPromise);\n            recomputeDependents(atom);\n          }\n        }\n        const flushed = flushPending();\n        storeListenersRev2.forEach(\n          (l) => l({ type: \"restore\", flushed })\n        );\n      }\n    };\n  }\n  return {\n    get: readAtom,\n    set: writeAtom,\n    sub: subscribeAtom\n  };\n};\nlet defaultStore;\nif ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n  if (typeof globalThis.__NUMBER_OF_JOTAI_INSTANCES__ === \"number\") {\n    ++globalThis.__NUMBER_OF_JOTAI_INSTANCES__;\n  } else {\n    globalThis.__NUMBER_OF_JOTAI_INSTANCES__ = 1;\n  }\n}\nconst getDefaultStore = () => {\n  if (!defaultStore) {\n    if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\" && globalThis.__NUMBER_OF_JOTAI_INSTANCES__ !== 1) {\n      console.warn(\n        \"Detected multiple Jotai instances. It may cause unexpected behavior with the default store. https://github.com/pmndrs/jotai/discussions/2044\"\n      );\n    }\n    defaultStore = createStore();\n  }\n  return defaultStore;\n};\n\nexport { atom, createStore, getDefaultStore };\n","'use client';\nimport ReactExports, { createContext, useContext, useRef, createElement, useReducer, useEffect, useDebugValue, useCallback } from 'react';\nimport { getDefaultStore, createStore } from 'jotai/vanilla';\n\nconst StoreContext = createContext(void 0);\nconst useStore = (options) => {\n  const store = useContext(StoreContext);\n  return (options == null ? void 0 : options.store) || store || getDefaultStore();\n};\nconst Provider = ({\n  children,\n  store\n}) => {\n  const storeRef = useRef();\n  if (!store && !storeRef.current) {\n    storeRef.current = createStore();\n  }\n  return createElement(\n    StoreContext.Provider,\n    {\n      value: store || storeRef.current\n    },\n    children\n  );\n};\n\nconst isPromiseLike = (x) => typeof (x == null ? void 0 : x.then) === \"function\";\nconst use = ReactExports.use || ((promise) => {\n  if (promise.status === \"pending\") {\n    throw promise;\n  } else if (promise.status === \"fulfilled\") {\n    return promise.value;\n  } else if (promise.status === \"rejected\") {\n    throw promise.reason;\n  } else {\n    promise.status = \"pending\";\n    promise.then(\n      (v) => {\n        promise.status = \"fulfilled\";\n        promise.value = v;\n      },\n      (e) => {\n        promise.status = \"rejected\";\n        promise.reason = e;\n      }\n    );\n    throw promise;\n  }\n});\nfunction useAtomValue(atom, options) {\n  const store = useStore(options);\n  const [[valueFromReducer, storeFromReducer, atomFromReducer], rerender] = useReducer(\n    (prev) => {\n      const nextValue = store.get(atom);\n      if (Object.is(prev[0], nextValue) && prev[1] === store && prev[2] === atom) {\n        return prev;\n      }\n      return [nextValue, store, atom];\n    },\n    void 0,\n    () => [store.get(atom), store, atom]\n  );\n  let value = valueFromReducer;\n  if (storeFromReducer !== store || atomFromReducer !== atom) {\n    rerender();\n    value = store.get(atom);\n  }\n  const delay = options == null ? void 0 : options.delay;\n  useEffect(() => {\n    const unsub = store.sub(atom, () => {\n      if (typeof delay === \"number\") {\n        setTimeout(rerender, delay);\n        return;\n      }\n      rerender();\n    });\n    rerender();\n    return unsub;\n  }, [store, atom, delay]);\n  useDebugValue(value);\n  return isPromiseLike(value) ? use(value) : value;\n}\n\nfunction useSetAtom(atom, options) {\n  const store = useStore(options);\n  const setAtom = useCallback(\n    (...args) => {\n      if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\" && !(\"write\" in atom)) {\n        throw new Error(\"not writable atom\");\n      }\n      return store.set(atom, ...args);\n    },\n    [store, atom]\n  );\n  return setAtom;\n}\n\nfunction useAtom(atom, options) {\n  return [\n    useAtomValue(atom, options),\n    // We do wrong type assertion here, which results in throwing an error.\n    useSetAtom(atom, options)\n  ];\n}\n\nexport { Provider, useAtom, useAtomValue, useSetAtom, useStore };\n","import { atom } from 'jotai/vanilla';\n\nconst RESET = Symbol(\n  (import.meta.env ? import.meta.env.MODE : void 0) !== \"production\" ? \"RESET\" : \"\"\n);\n\nfunction atomWithReset(initialValue) {\n  const anAtom = atom(\n    initialValue,\n    (get, set, update) => {\n      const nextValue = typeof update === \"function\" ? update(get(anAtom)) : update;\n      set(anAtom, nextValue === RESET ? initialValue : nextValue);\n    }\n  );\n  return anAtom;\n}\n\nfunction atomWithReducer(initialValue, reducer) {\n  const anAtom = atom(\n    initialValue,\n    (get, set, action) => set(anAtom, reducer(get(anAtom), action))\n  );\n  return anAtom;\n}\n\nfunction atomFamily(initializeAtom, areEqual) {\n  let shouldRemove = null;\n  const atoms = /* @__PURE__ */ new Map();\n  const createAtom = (param) => {\n    let item;\n    if (areEqual === void 0) {\n      item = atoms.get(param);\n    } else {\n      for (const [key, value] of atoms) {\n        if (areEqual(key, param)) {\n          item = value;\n          break;\n        }\n      }\n    }\n    if (item !== void 0) {\n      if (shouldRemove == null ? void 0 : shouldRemove(item[1], param)) {\n        createAtom.remove(param);\n      } else {\n        return item[0];\n      }\n    }\n    const newAtom = initializeAtom(param);\n    atoms.set(param, [newAtom, Date.now()]);\n    return newAtom;\n  };\n  createAtom.remove = (param) => {\n    if (areEqual === void 0) {\n      atoms.delete(param);\n    } else {\n      for (const [key] of atoms) {\n        if (areEqual(key, param)) {\n          atoms.delete(key);\n          break;\n        }\n      }\n    }\n  };\n  createAtom.setShouldRemove = (fn) => {\n    shouldRemove = fn;\n    if (!shouldRemove)\n      return;\n    for (const [key, value] of atoms) {\n      if (shouldRemove(value[1], key)) {\n        atoms.delete(key);\n      }\n    }\n  };\n  return createAtom;\n}\n\nconst getCached$2 = (c, m, k) => (m.has(k) ? m : m.set(k, c())).get(k);\nconst cache1$4 = /* @__PURE__ */ new WeakMap();\nconst memo3 = (create, dep1, dep2, dep3) => {\n  const cache2 = getCached$2(() => /* @__PURE__ */ new WeakMap(), cache1$4, dep1);\n  const cache3 = getCached$2(() => /* @__PURE__ */ new WeakMap(), cache2, dep2);\n  return getCached$2(create, cache3, dep3);\n};\nfunction selectAtom(anAtom, selector, equalityFn = Object.is) {\n  return memo3(\n    () => {\n      const EMPTY = Symbol();\n      const selectValue = ([value, prevSlice]) => {\n        if (prevSlice === EMPTY) {\n          return selector(value);\n        }\n        const slice = selector(value, prevSlice);\n        return equalityFn(prevSlice, slice) ? prevSlice : slice;\n      };\n      const derivedAtom = atom((get) => {\n        const prev = get(derivedAtom);\n        const value = get(anAtom);\n        if (value instanceof Promise || prev instanceof Promise) {\n          return Promise.all([value, prev]).then(selectValue);\n        }\n        return selectValue([value, prev]);\n      });\n      derivedAtom.init = EMPTY;\n      return derivedAtom;\n    },\n    anAtom,\n    selector,\n    equalityFn\n  );\n}\n\nconst cache1$3 = /* @__PURE__ */ new WeakMap();\nconst memo1$1 = (create, dep1) => (cache1$3.has(dep1) ? cache1$3 : cache1$3.set(dep1, create())).get(dep1);\nconst deepFreeze = (obj) => {\n  if (typeof obj !== \"object\" || obj === null)\n    return;\n  Object.freeze(obj);\n  const propNames = Object.getOwnPropertyNames(obj);\n  for (const name of propNames) {\n    const value = obj[name];\n    deepFreeze(value);\n  }\n  return obj;\n};\nfunction freezeAtom(anAtom) {\n  return memo1$1(() => {\n    const frozenAtom = atom(\n      (get) => deepFreeze(get(anAtom)),\n      (_get, set, arg) => set(anAtom, arg)\n    );\n    return frozenAtom;\n  }, anAtom);\n}\nfunction freezeAtomCreator(createAtom) {\n  return (...params) => {\n    const anAtom = createAtom(...params);\n    const origRead = anAtom.read;\n    anAtom.read = function(get, options) {\n      return deepFreeze(origRead.call(this, get, options));\n    };\n    return anAtom;\n  };\n}\n\nconst getCached$1 = (c, m, k) => (m.has(k) ? m : m.set(k, c())).get(k);\nconst cache1$2 = /* @__PURE__ */ new WeakMap();\nconst memo2$1 = (create, dep1, dep2) => {\n  const cache2 = getCached$1(() => /* @__PURE__ */ new WeakMap(), cache1$2, dep1);\n  return getCached$1(create, cache2, dep2);\n};\nconst cacheKeyForEmptyKeyExtractor = {};\nconst isWritable = (atom2) => !!atom2.write;\nconst isFunction = (x) => typeof x === \"function\";\nfunction splitAtom(arrAtom, keyExtractor) {\n  return memo2$1(\n    () => {\n      const mappingCache = /* @__PURE__ */ new WeakMap();\n      const getMapping = (arr, prev) => {\n        let mapping = mappingCache.get(arr);\n        if (mapping) {\n          return mapping;\n        }\n        const prevMapping = prev && mappingCache.get(prev);\n        const atomList = [];\n        const keyList = [];\n        arr.forEach((item, index) => {\n          const key = keyExtractor ? keyExtractor(item) : index;\n          keyList[index] = key;\n          const cachedAtom = prevMapping && prevMapping.atomList[prevMapping.keyList.indexOf(key)];\n          if (cachedAtom) {\n            atomList[index] = cachedAtom;\n            return;\n          }\n          const read = (get) => {\n            const prev2 = get(mappingAtom);\n            const currArr = get(arrAtom);\n            const mapping2 = getMapping(currArr, prev2 == null ? void 0 : prev2.arr);\n            const index2 = mapping2.keyList.indexOf(key);\n            if (index2 < 0 || index2 >= currArr.length) {\n              const prevItem = arr[getMapping(arr).keyList.indexOf(key)];\n              if (prevItem) {\n                return prevItem;\n              }\n              throw new Error(\"splitAtom: index out of bounds for read\");\n            }\n            return currArr[index2];\n          };\n          const write = (get, set, update) => {\n            const prev2 = get(mappingAtom);\n            const arr2 = get(arrAtom);\n            const mapping2 = getMapping(arr2, prev2 == null ? void 0 : prev2.arr);\n            const index2 = mapping2.keyList.indexOf(key);\n            if (index2 < 0 || index2 >= arr2.length) {\n              throw new Error(\"splitAtom: index out of bounds for write\");\n            }\n            const nextItem = isFunction(update) ? update(arr2[index2]) : update;\n            if (!Object.is(arr2[index2], nextItem)) {\n              set(arrAtom, [\n                ...arr2.slice(0, index2),\n                nextItem,\n                ...arr2.slice(index2 + 1)\n              ]);\n            }\n          };\n          atomList[index] = isWritable(arrAtom) ? atom(read, write) : atom(read);\n        });\n        if (prevMapping && prevMapping.keyList.length === keyList.length && prevMapping.keyList.every((x, i) => x === keyList[i])) {\n          mapping = prevMapping;\n        } else {\n          mapping = { arr, atomList, keyList };\n        }\n        mappingCache.set(arr, mapping);\n        return mapping;\n      };\n      const mappingAtom = atom((get) => {\n        const prev = get(mappingAtom);\n        const arr = get(arrAtom);\n        const mapping = getMapping(arr, prev == null ? void 0 : prev.arr);\n        return mapping;\n      });\n      if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n        mappingAtom.debugPrivate = true;\n      }\n      mappingAtom.init = void 0;\n      const splittedAtom = isWritable(arrAtom) ? atom(\n        (get) => get(mappingAtom).atomList,\n        (get, set, action) => {\n          switch (action.type) {\n            case \"remove\": {\n              const index = get(splittedAtom).indexOf(action.atom);\n              if (index >= 0) {\n                const arr = get(arrAtom);\n                set(arrAtom, [\n                  ...arr.slice(0, index),\n                  ...arr.slice(index + 1)\n                ]);\n              }\n              break;\n            }\n            case \"insert\": {\n              const index = action.before ? get(splittedAtom).indexOf(action.before) : get(splittedAtom).length;\n              if (index >= 0) {\n                const arr = get(arrAtom);\n                set(arrAtom, [\n                  ...arr.slice(0, index),\n                  action.value,\n                  ...arr.slice(index)\n                ]);\n              }\n              break;\n            }\n            case \"move\": {\n              const index1 = get(splittedAtom).indexOf(action.atom);\n              const index2 = action.before ? get(splittedAtom).indexOf(action.before) : get(splittedAtom).length;\n              if (index1 >= 0 && index2 >= 0) {\n                const arr = get(arrAtom);\n                if (index1 < index2) {\n                  set(arrAtom, [\n                    ...arr.slice(0, index1),\n                    ...arr.slice(index1 + 1, index2),\n                    arr[index1],\n                    ...arr.slice(index2)\n                  ]);\n                } else {\n                  set(arrAtom, [\n                    ...arr.slice(0, index2),\n                    arr[index1],\n                    ...arr.slice(index2, index1),\n                    ...arr.slice(index1 + 1)\n                  ]);\n                }\n              }\n              break;\n            }\n          }\n        }\n      ) : atom((get) => get(mappingAtom).atomList);\n      return splittedAtom;\n    },\n    arrAtom,\n    keyExtractor || cacheKeyForEmptyKeyExtractor\n  );\n}\n\nfunction atomWithDefault(getDefault) {\n  const EMPTY = Symbol();\n  const overwrittenAtom = atom(EMPTY);\n  if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n    overwrittenAtom.debugPrivate = true;\n  }\n  const anAtom = atom(\n    (get, options) => {\n      const overwritten = get(overwrittenAtom);\n      if (overwritten !== EMPTY) {\n        return overwritten;\n      }\n      return getDefault(get, options);\n    },\n    (get, set, update) => {\n      if (update === RESET) {\n        set(overwrittenAtom, EMPTY);\n      } else if (typeof update === \"function\") {\n        const prevValue = get(anAtom);\n        set(overwrittenAtom, update(prevValue));\n      } else {\n        set(overwrittenAtom, update);\n      }\n    }\n  );\n  return anAtom;\n}\n\nconst isPromiseLike = (x) => typeof (x == null ? void 0 : x.then) === \"function\";\nfunction withStorageValidator(validator) {\n  return (unknownStorage) => {\n    const storage = {\n      ...unknownStorage,\n      getItem: (key, initialValue) => {\n        const validate = (value2) => {\n          if (!validator(value2)) {\n            return initialValue;\n          }\n          return value2;\n        };\n        const value = unknownStorage.getItem(key, initialValue);\n        if (isPromiseLike(value)) {\n          return value.then(validate);\n        }\n        return validate(value);\n      }\n    };\n    return storage;\n  };\n}\nfunction createJSONStorage(getStringStorage = () => typeof window !== \"undefined\" ? window.localStorage : void 0, options) {\n  let lastStr;\n  let lastValue;\n  const storage = {\n    getItem: (key, initialValue) => {\n      var _a, _b;\n      const parse = (str2) => {\n        str2 = str2 || \"\";\n        if (lastStr !== str2) {\n          try {\n            lastValue = JSON.parse(str2, options == null ? void 0 : options.reviver);\n          } catch {\n            return initialValue;\n          }\n          lastStr = str2;\n        }\n        return lastValue;\n      };\n      const str = (_b = (_a = getStringStorage()) == null ? void 0 : _a.getItem(key)) != null ? _b : null;\n      if (isPromiseLike(str)) {\n        return str.then(parse);\n      }\n      return parse(str);\n    },\n    setItem: (key, newValue) => {\n      var _a;\n      return (_a = getStringStorage()) == null ? void 0 : _a.setItem(\n        key,\n        JSON.stringify(newValue, options == null ? void 0 : options.replacer)\n      );\n    },\n    removeItem: (key) => {\n      var _a;\n      return (_a = getStringStorage()) == null ? void 0 : _a.removeItem(key);\n    }\n  };\n  if (typeof window !== \"undefined\" && typeof window.addEventListener === \"function\" && window.Storage) {\n    storage.subscribe = (key, callback, initialValue) => {\n      if (!(getStringStorage() instanceof window.Storage)) {\n        return () => {\n        };\n      }\n      const storageEventCallback = (e) => {\n        if (e.storageArea === getStringStorage() && e.key === key) {\n          let newValue;\n          try {\n            newValue = JSON.parse(e.newValue || \"\");\n          } catch {\n            newValue = initialValue;\n          }\n          callback(newValue);\n        }\n      };\n      window.addEventListener(\"storage\", storageEventCallback);\n      return () => {\n        window.removeEventListener(\"storage\", storageEventCallback);\n      };\n    };\n  }\n  return storage;\n}\nconst defaultStorage = createJSONStorage();\nfunction atomWithStorage(key, initialValue, storage = defaultStorage, options) {\n  const getOnInit = options == null ? void 0 : options.getOnInit;\n  const baseAtom = atom(\n    getOnInit ? storage.getItem(key, initialValue) : initialValue\n  );\n  if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n    baseAtom.debugPrivate = true;\n  }\n  baseAtom.onMount = (setAtom) => {\n    if (!getOnInit) {\n      setAtom(storage.getItem(key, initialValue));\n    }\n    let unsub;\n    if (storage.subscribe) {\n      unsub = storage.subscribe(key, setAtom, initialValue);\n    }\n    return unsub;\n  };\n  const anAtom = atom(\n    (get) => get(baseAtom),\n    (get, set, update) => {\n      const nextValue = typeof update === \"function\" ? update(get(baseAtom)) : update;\n      if (nextValue === RESET) {\n        set(baseAtom, initialValue);\n        return storage.removeItem(key);\n      }\n      if (nextValue instanceof Promise) {\n        return nextValue.then((resolvedValue) => {\n          set(baseAtom, resolvedValue);\n          return storage.setItem(key, resolvedValue);\n        });\n      }\n      set(baseAtom, nextValue);\n      return storage.setItem(key, nextValue);\n    }\n  );\n  return anAtom;\n}\n\nfunction atomWithObservable(getObservable, options) {\n  const returnResultData = (result) => {\n    if (\"e\" in result) {\n      throw result.e;\n    }\n    return result.d;\n  };\n  const observableResultAtom = atom((get) => {\n    var _a;\n    let observable = getObservable(get);\n    const itself = (_a = observable[Symbol.observable]) == null ? void 0 : _a.call(observable);\n    if (itself) {\n      observable = itself;\n    }\n    let resolve;\n    const makePending = () => new Promise((r) => {\n      resolve = r;\n    });\n    const initialResult = options && \"initialValue\" in options ? {\n      d: typeof options.initialValue === \"function\" ? options.initialValue() : options.initialValue\n    } : makePending();\n    let setResult;\n    let lastResult;\n    const listener = (result) => {\n      lastResult = result;\n      resolve == null ? void 0 : resolve(result);\n      setResult == null ? void 0 : setResult(result);\n    };\n    let subscription;\n    let timer;\n    const isNotMounted = () => !setResult;\n    const start = () => {\n      if (subscription) {\n        clearTimeout(timer);\n        subscription.unsubscribe();\n      }\n      subscription = observable.subscribe({\n        next: (d) => listener({ d }),\n        error: (e) => listener({ e }),\n        complete: () => {\n        }\n      });\n      if (isNotMounted() && (options == null ? void 0 : options.unstable_timeout)) {\n        timer = setTimeout(() => {\n          if (subscription) {\n            subscription.unsubscribe();\n            subscription = void 0;\n          }\n        }, options.unstable_timeout);\n      }\n    };\n    start();\n    const resultAtom = atom(lastResult || initialResult);\n    if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n      resultAtom.debugPrivate = true;\n    }\n    resultAtom.onMount = (update) => {\n      setResult = update;\n      if (lastResult) {\n        update(lastResult);\n      }\n      if (subscription) {\n        clearTimeout(timer);\n      } else {\n        start();\n      }\n      return () => {\n        setResult = void 0;\n        if (subscription) {\n          subscription.unsubscribe();\n          subscription = void 0;\n        }\n      };\n    };\n    return [resultAtom, observable, makePending, start, isNotMounted];\n  });\n  if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n    observableResultAtom.debugPrivate = true;\n  }\n  const observableAtom = atom(\n    (get) => {\n      const [resultAtom] = get(observableResultAtom);\n      const result = get(resultAtom);\n      if (result instanceof Promise) {\n        return result.then(returnResultData);\n      }\n      return returnResultData(result);\n    },\n    (get, set, data) => {\n      const [resultAtom, observable, makePending, start, isNotMounted] = get(observableResultAtom);\n      if (\"next\" in observable) {\n        if (isNotMounted()) {\n          set(resultAtom, makePending());\n          start();\n        }\n        observable.next(data);\n      } else {\n        throw new Error(\"observable is not subject\");\n      }\n    }\n  );\n  return observableAtom;\n}\n\nconst cache1$1 = /* @__PURE__ */ new WeakMap();\nconst memo1 = (create, dep1) => (cache1$1.has(dep1) ? cache1$1 : cache1$1.set(dep1, create())).get(dep1);\nconst LOADING = { state: \"loading\" };\nfunction loadable(anAtom) {\n  return memo1(() => {\n    const loadableCache = /* @__PURE__ */ new WeakMap();\n    const refreshAtom = atom(0);\n    if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n      refreshAtom.debugPrivate = true;\n    }\n    const derivedAtom = atom(\n      (get, { setSelf }) => {\n        get(refreshAtom);\n        let value;\n        try {\n          value = get(anAtom);\n        } catch (error) {\n          return { state: \"hasError\", error };\n        }\n        if (!(value instanceof Promise)) {\n          return { state: \"hasData\", data: value };\n        }\n        const promise = value;\n        const cached = loadableCache.get(promise);\n        if (cached) {\n          return cached;\n        }\n        loadableCache.set(promise, LOADING);\n        promise.then(\n          (data) => {\n            loadableCache.set(promise, { state: \"hasData\", data });\n          },\n          (error) => {\n            loadableCache.set(promise, { state: \"hasError\", error });\n          }\n        ).finally(setSelf);\n        return LOADING;\n      },\n      (_get, set) => {\n        set(refreshAtom, (c) => c + 1);\n      }\n    );\n    if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n      derivedAtom.debugPrivate = true;\n    }\n    return atom((get) => get(derivedAtom));\n  }, anAtom);\n}\n\nconst getCached = (c, m, k) => (m.has(k) ? m : m.set(k, c())).get(k);\nconst cache1 = /* @__PURE__ */ new WeakMap();\nconst memo2 = (create, dep1, dep2) => {\n  const cache2 = getCached(() => /* @__PURE__ */ new WeakMap(), cache1, dep1);\n  return getCached(create, cache2, dep2);\n};\nconst defaultFallback = () => void 0;\nfunction unwrap(anAtom, fallback = defaultFallback) {\n  return memo2(\n    () => {\n      const promiseErrorCache = /* @__PURE__ */ new WeakMap();\n      const promiseResultCache = /* @__PURE__ */ new WeakMap();\n      const refreshAtom = atom(0);\n      if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n        refreshAtom.debugPrivate = true;\n      }\n      const promiseAndValueAtom = atom(\n        (get, { setSelf }) => {\n          get(refreshAtom);\n          const prev = get(promiseAndValueAtom);\n          const promise = get(anAtom);\n          if (!(promise instanceof Promise)) {\n            return { v: promise };\n          }\n          if (promise === (prev == null ? void 0 : prev.p)) {\n            if (promiseErrorCache.has(promise)) {\n              throw promiseErrorCache.get(promise);\n            }\n            if (promiseResultCache.has(promise)) {\n              return {\n                p: promise,\n                v: promiseResultCache.get(promise)\n              };\n            }\n          }\n          if (promise !== (prev == null ? void 0 : prev.p)) {\n            promise.then(\n              (v) => promiseResultCache.set(promise, v),\n              (e) => promiseErrorCache.set(promise, e)\n            ).finally(setSelf);\n          }\n          if (prev && \"v\" in prev) {\n            return { p: promise, f: fallback(prev.v), v: prev.v };\n          }\n          return { p: promise, f: fallback() };\n        },\n        (_get, set) => {\n          set(refreshAtom, (c) => c + 1);\n        }\n      );\n      promiseAndValueAtom.init = void 0;\n      if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n        promiseAndValueAtom.debugPrivate = true;\n      }\n      return atom(\n        (get) => {\n          const state = get(promiseAndValueAtom);\n          if (\"f\" in state) {\n            return state.f;\n          }\n          return state.v;\n        },\n        (_get, set, ...args) => set(anAtom, ...args)\n      );\n    },\n    anAtom,\n    fallback\n  );\n}\n\nexport { RESET, atomFamily, atomWithDefault, atomWithObservable, atomWithReducer, atomWithReset, atomWithStorage, createJSONStorage, freezeAtom, freezeAtomCreator, loadable, selectAtom, splitAtom, withStorageValidator as unstable_withStorageValidator, unwrap };\n","import { useMemo, useEffect, useState } from 'react'\nimport { dequal } from 'dequal'\nimport { atom, useAtom, useAtomValue, useSetAtom } from 'jotai'\nimport { atomFamily } from 'jotai/utils'\nimport type {\n  PageLoaded,\n  UseStaticData,\n  Theme,\n  UseAllPagesOutlines,\n} from '../../clientTypes'\n\nexport let useTheme: () => Theme\nexport let usePagePaths: () => string[]\nexport let usePageModule: (path: string) => Promise<PageModule> | undefined\nexport let useStaticData: UseStaticData\nexport let useAllPagesOutlines: UseAllPagesOutlines\n\ninterface PageModule {\n  ['default']: PageLoaded\n}\ntype SetAtom<Args extends any[], Result> = (...args: Args) => Result\n\nimport initialPages from '/@react-pages/pages'\nimport initialTheme from '/@react-pages/theme'\n\n// TODO: simplify this\n// there is no easy way to handle the hmr of module such as `/@react-pages/pages/page1` so stop trying it\n// https://github.com/vitejs/vite-plugin-react-pages/pull/19#discussion_r604251258\n\nconst initialPagePaths = Object.keys(initialPages)\n\n// This HMR code assumes that our Jotai atoms are always managed\n// by the same Provider. It also mutates during render, which is\n// generally discouraged, but in this case it's okay.\nif (import.meta.hot) {\n  let setTheme: SetAtom<[{ Theme: Theme }], void> | undefined\n  import.meta.hot!.accept('/@react-pages/theme', (module) => {\n    // console.log('@@hot update /@react-pages/theme', module)\n    if (!module) {\n      console.error('unexpected hot module', module)\n      return\n    }\n    setTheme?.({ Theme: module.default })\n  })\n\n  const themeAtom = atom({ Theme: initialTheme })\n  useTheme = () => {\n    const [{ Theme }, set] = useAtom(themeAtom)\n    setTheme = set\n    return Theme\n  }\n\n  let setPages: SetAtom<any, void> | undefined\n  import.meta.hot!.accept('/@react-pages/pages', (module) => {\n    // console.log('@@hot update /@react-pages/pages', module)\n    if (!module) {\n      console.error('unexpected hot module', module)\n      return\n    }\n    setPages?.(module.default)\n  })\n\n  // let setAllPagesOutlines: SetAtom<any, void> | undefined\n  // import.meta.hot!.accept('/@react-pages/allPagesOutlines', (module) => {\n  //   // console.log('@@hot update /@react-pages/allPagesOutlines', module)\n  //   if (!module) {\n  //     console.error('unexpected hot module', module)\n  //     return\n  //   }\n  //   setAllPagesOutlines?.(module)\n  // })\n\n  const pagesAtom = atom(initialPages)\n  const pagePathsAtom = atom(initialPagePaths.sort())\n  const staticDataAtom = atom(toStaticData(initialPages))\n  const allPagesOutlinesAtom = atom(initialPages)\n\n  const setPagesAtom = atom(null, (get, set, newPages: any) => {\n    let newStaticData: Record<string, any> | undefined\n\n    const pages = get(pagesAtom)\n    for (const path in newPages) {\n      const newPage = newPages[path]\n      const page = pages[path]\n\n      // Avoid changing the identity of `page.staticData` unless\n      // a change is detected. This prevents unnecessary renders\n      // of components that depend on `useStaticData(path)` call.\n      if (page && dequal(page.staticData, newPage.staticData)) {\n        newPage.staticData = page.staticData\n      } else {\n        newStaticData ??= {}\n        newStaticData[path] = newPage.staticData\n      }\n    }\n\n    // detect deleted pages\n    for (const path in pages) {\n      if (!newPages[path]) {\n        newStaticData ??= {}\n        newStaticData[path] = undefined\n      }\n    }\n\n    // Update the `pagesAtom` every time, since no hook uses it directly.\n    set(pagesAtom, newPages)\n\n    // Avoid re-rendering `useStaticData()` callers if no data changed.\n    if (newStaticData) {\n      newStaticData = {\n        ...get(staticDataAtom),\n        ...newStaticData,\n      }\n      // filter out deleted paths\n      newStaticData = Object.fromEntries(\n        Object.entries(newStaticData).filter(([k, v]) => v !== undefined)\n      )\n      set(staticDataAtom, newStaticData)\n    }\n\n    // Avoid re-rendering `usePagePaths()` callers if no paths were added/deleted.\n    const newPagePaths = Object.keys(newPages).sort()\n    if (!dequal(get(pagePathsAtom), newPagePaths)) {\n      set(pagePathsAtom, newPagePaths)\n    }\n  })\n\n  const dataAtoms = atomFamily((path: string) =>\n    atom((get) => {\n      const pages = get(pagesAtom)\n      return pages[path]\n    })\n  )\n\n  const staticDataAtoms = atomFamily((path: string) =>\n    atom((get) => {\n      const pages = get(pagesAtom)\n      const page = pages[path]\n      return page?.staticData\n    })\n  )\n\n  usePagePaths = () => {\n    setPages = useSetAtom(setPagesAtom)\n    return useAtomValue(pagePathsAtom)\n  }\n\n  usePageModule = (pagePath) => {\n    const data = useAtomValue(dataAtoms(pagePath))\n    return useMemo(() => data?.data(), [data])\n  }\n\n  useStaticData = (pagePath?: string, selector?: Function) => {\n    const staticData = pagePath ? staticDataAtoms(pagePath) : staticDataAtom\n    if (selector) {\n      const selection = useMemo(\n        () => atom((get) => selector(get(staticData))),\n        [staticData]\n      )\n      return useAtomValue(selection)\n    }\n    return useAtomValue(staticData)\n  }\n\n  useAllPagesOutlines = (timeout: number) => {\n    const [data, set] = useAtom(allPagesOutlinesAtom)\n    // setAllPagesOutlines = set\n    useEffect(() => {\n      setTimeout(() => {\n        import('/@react-pages/allPagesOutlines').then((mod) => {\n          set(mod)\n        })\n      }, timeout)\n    }, [])\n    return data\n  }\n}\n\n// Static mode\nelse {\n  useTheme = () => initialTheme\n  usePagePaths = () => initialPagePaths\n  usePageModule = (path) => {\n    const page = initialPages[path]\n    return useMemo(() => page?.data(), [page])\n  }\n  useStaticData = (path?: string, selector?: Function) => {\n    if (path) {\n      const page = initialPages[path]\n      const staticData = page?.staticData || {}\n      return selector ? selector(staticData) : staticData\n    }\n    return toStaticData(initialPages)\n  }\n  useAllPagesOutlines = (timeout: number) => {\n    const [data, set] = useState<any>()\n    useEffect(() => {\n      setTimeout(() => {\n        import('/@react-pages/allPagesOutlines').then((mod) => {\n          set(mod)\n        })\n      }, timeout)\n    }, [])\n    return data\n  }\n}\n\nfunction toStaticData(pages: Record<string, any>) {\n  const staticData: Record<string, any> = {}\n  for (const path in pages) {\n    staticData[path] = pages[path].staticData\n  }\n  return staticData\n}\n\nif ((globalThis as any)['__vite_pages_use_static_data']) {\n  throw new Error(\n    `[vite-pages] global hooks (.e.g useStaticData) already exists on window. It means there are multiple vite-pages runtime in this page. Please report this to vite-pages.`\n  )\n} else {\n  // make them available in vite-plugin-react-pages/client\n  ;(globalThis as any)['__vite_pages_use_static_data'] = useStaticData\n  ;(globalThis as any)['__vite_pages_use_all_pages_outlines'] =\n    useAllPagesOutlines\n}\n","import { useLayoutEffect, useEffect } from 'react'\n\nexport const isSSR = import.meta.env.SSR\n\n// fix warning of useLayoutEffect during ssr\n// https://gist.github.com/gaearon/e7d97cdf38a2907924ea12e4ebdf3c85\nexport const useIsomorphicLayoutEffect = isSSR ? useEffect : useLayoutEffect\n","import { useState, useContext, useRef } from 'react'\nimport { unstable_batchedUpdates as batchedUpdates } from 'react-dom'\nimport type { LoadState } from '../../clientTypes'\nimport { dataCacheCtx, setDataCacheCtx } from './ctx'\nimport { usePageModule } from './state'\nimport { useIsomorphicLayoutEffect } from './utils'\n\nexport default function useAppState(routePath: string) {\n  const dataCache = useContext(dataCacheCtx)\n  const setDataCache = useContext(setDataCacheCtx)\n\n  const [loadState, setLoadState] = useState<LoadState>(() => {\n    if (dataCache[routePath]) {\n      // this is a ssr or hydration\n      // this page's data has already been loaded\n      return {\n        type: 'loaded',\n        routePath,\n      }\n    }\n    if (routePath === '/internal-404-page') {\n      // this is a ssr or hydration\n      // for the 404 page\n      return {\n        type: '404',\n        routePath,\n      }\n    }\n    return {\n      type: 'loading',\n      routePath,\n    }\n  })\n\n  const onLoadState = (\n    type: LoadState['type'],\n    routePath: string,\n    error?: any\n  ) => setLoadState({ type, routePath, error })\n\n  const loading = usePageModule(routePath)\n  const loadingRef = useRef<Promise<any> | undefined>()\n  useIsomorphicLayoutEffect(() => {\n    loadingRef.current = loading\n    if (!loading) {\n      onLoadState('404', routePath)\n    } else {\n      if (dataCache[routePath]) {\n        /**\n         * Data already exists. Possible causes:\n         * - User navigates back to a loaded page.\n         * - This is a hmr update during dev. The dataCache[routePath] contains the old data. We need to load() the new data (but don't show loading state).\n         * - This is a ssr client-side render. The page data is loaded before hydration.\n         */\n        onLoadState('loaded', routePath)\n        if (import.meta.hot) {\n          // If user navigates back to a loaded page during dev\n          // this will also be executed.\n          // But in this case, it will import() the same es module again,\n          // which is handled by the browser es module cache.\n          // So it won't load the module from dev server again and won't evaluate the module again.\n          load()\n        }\n      } else {\n        onLoadState('loading', routePath)\n        load()\n      }\n    }\n\n    function load() {\n      loading!.then(\n        (page) =>\n          loading === loadingRef.current &&\n          batchedUpdates(() => {\n            onLoadState('loaded', routePath)\n            setDataCache((prev) => ({\n              ...prev,\n              [routePath]: page.default,\n            }))\n          }),\n        (error) =>\n          loading === loadingRef.current &&\n          onLoadState('load-error', routePath, error)\n      )\n    }\n  }, [loading])\n\n  return loadState\n}\n","import React, { useContext } from 'react'\nimport { dataCacheCtx } from './ctx'\nimport { useTheme } from './state'\nimport useAppState from './useAppState'\n\ninterface Props {\n  routePath: string\n}\n\nconst PageLoader = React.memo(({ routePath }: Props) => {\n  const Theme = useTheme()\n  const loadState = useAppState(routePath)\n  const dataCache = useContext(dataCacheCtx)\n\n  return <Theme loadState={loadState} loadedData={dataCache} />\n})\n\nexport default PageLoader\n","import React from 'react'\nimport {\n  useRoutes,\n  useLocation,\n  type Location,\n  type RouteObject,\n} from 'react-router-dom'\nimport { usePagePaths } from './state'\nimport PageLoader from './PageLoader'\n\nconst App = () => {\n  const pageRoutes = usePagePaths()\n    .filter((path) => path !== '/404')\n    .map((path) => {\n      return { path, element: <PageLoader routePath={path} /> } as RouteObject\n    })\n\n  pageRoutes.push({\n    path: '*',\n    element: (\n      <UseLocation>\n        {(location) => <PageLoader routePath={location.pathname} />}\n      </UseLocation>\n    ),\n  })\n\n  const routesRender = useRoutes(pageRoutes)\n\n  return routesRender\n}\n\nexport default App\n\nfunction UseLocation({ children }: { children: (location: Location) => any }) {\n  const location = useLocation()\n  // console.log('###UseLocation', location)\n  return children(location)\n}\n","/**\n * This is the entry for client-side-render(csr).\n * Used in: dev mode, build mode.\n */\n\nimport React from 'react'\nimport { createRoot } from 'react-dom/client'\n\nimport ClientAppWrapper from './ClientAppWrapper'\nimport App from '../App'\n\nconst container = document.getElementById('root')!\nconst root = createRoot(container)\nroot.render(\n  <ClientAppWrapper>\n    <App />\n  </ClientAppWrapper>\n)\n"],"names":["dataCacheCtx","createContext","setDataCacheCtx","Error","Router","__HASH_ROUTER__","HashRouter","BrowserRouter","basename","undefined","import","meta","env","BASE_URL","replace","ClientAppWrapper","initCache","children","dataCache","setDataCache","useState","_jsx","Provider","value","isPromiseLike","useTheme","usePagePaths","usePageModule","useStaticData","useAllPagesOutlines","initialPagePaths","Object","keys","initialPages","hot","setTheme","accept","module","console","error","Theme","default","themeAtom","atom","initialTheme","set","useAtom","setPages","pagesAtom","pagePathsAtom","sort","staticDataAtom","toStaticData","allPagesOutlinesAtom","setPagesAtom","get","newPages","newStaticData","pages","path","newPage","page","dequal","staticData","fromEntries","entries","filter","k","v","newPagePaths","dataAtoms","atomFamily","staticDataAtoms","useSetAtom","useAtomValue","pagePath","data","useMemo","selector","selection","timeout","useEffect","setTimeout","then","mod","globalThis","isSSR","SSR","useIsomorphicLayoutEffect","useLayoutEffect","useAppState","routePath","useContext","loadState","setLoadState","type","onLoadState","loading","loadingRef","useRef","current","load","batchedUpdates","prev","PageLoader","React","memo","loadedData","App","pageRoutes","map","element","push","UseLocation","location","pathname","routesRender","useRoutes","useLocation","container","document","getElementById","root","createRoot","render"],"mappings":"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","x_google_ignoreList":[2,3,4]}